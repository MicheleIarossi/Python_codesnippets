.. Python codesnippets documentation master file, created by
   sphinx-quickstart on Sun Jan  3 00:51:56 2021.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Welcome to Python *codesnippets* documentation!
===============================================

A collection of Python code snippets explaining or showing particular features
of the language (Python 3 only).

It provides ready-to-run and short *codesnippets* that can be used for experimenting with or refreshing particular language features.

The examples have been inspired by the massive
tome `Learning Python 5th Edition (June 2013) by Mark Lutz, O'Reilly Media Inc. <https://learning-python.com/about-lp.html>`_,
which I highly recommend.

The order of the topics follows more or less the one in the book, but the code snippets have been readapted by myself.

For questions or suggestions please contact me at micheleiarossi@gmail.com . Thanks!

Table of contents
=================

.. toctree::
   :maxdepth: 1

   Installation<install.rst>
   Running the codesnippets<examples.rst>
   Add your own codesnippet<expand.rst>
   dir() on an integer variable<feature1.rst>
   Slicing strings<feature2.rst>
   Transforming a string into a list<feature3.rst>
   Formatting string expressions with the basic syntax<feature4.rst>
   Formatting string expressions with .format() syntax<feature5.rst>
   Formatting string expressions with f-strings syntax<feature6.rst>
   Changing lists in place<feature7.rst>
   List comprehension<feature8.rst>
   map() on the elements of a list<feature9.rst>
   Dictionaries<feature10.rst>
   Merging dictionaries by dictionary unpacking<feature11.rst>
   Sorting items of a dictionary<feature12.rst>
   Assignment unpacking<feature13.rst>
   Shallow and deep copy<feature14.rst>
   Comparison and equality<feature15.rst>
   More assignment unpacking<feature16.rst>
   First, rest pattern<feature17.rst>
   Side effects in assignments<feature18.rst>
   Dictionary-based C-type switch<feature19.rst>
   Boolean and/or operators<feature20.rst>
   Ternary expression<feature21.rst>
   Parallel traversals with zip()<feature22.rst>
   Dictionary construction with zip()<feature23.rst>
   Loop with enumerate()<feature24.rst>
   Side effects in loops<feature25.rst>
   The iteration protocol<feature26.rst>
   List comprehension on a file<feature27.rst>
   Function definitions<feature28.rst>
   Accessing global variables<feature29.rst>
   The LEGB rule (nested scopes)<feature30.rst>
   How to avoid nested scopes<feature31.rst>
   Factory function (state retention)<feature32.rst>
   Factory function with lambda<feature33.rst>
   Factory function with lambda and defaults<feature34.rst>
   Accessing non-local variables<feature35.rst>
   State retention using mutable list<feature36.rst>
   Simulating output parameters in a function call<feature37.rst>
   Arguments matched by default values, by position and by name<feature38.rst>
   Arbitrary arguments<feature39.rst>
   Unpacking arguments<feature40.rst>
   Keyword only arguments<feature41.rst>
   Recursion<feature42.rst>
   Avoiding recursive calls by depth-first scanning<feature43.rst>
   Avoiding recursive calls by breadth-first scanning<feature44.rst>
   Lambda functions<feature45.rst>
   Lambda functions, map() and list comprehension<feature46.rst>
   Function generators<feature47.rst>
   Expression generators<feature48.rst>
   Module import information<feature49.rst>
   Module import<feature50.rst>
   Side effects when importing modules<feature51.rst>
   Module reload<feature52.rst>
   Module packages<feature53.rst>
   Absolute import from a module package<feature54.rst>
   Relative import from a module package<feature55.rst>   
   Module attribute access<feature56.rst>
   Module imports with importlib<feature57.rst>  
   First classes<feature58.rst>
   Built-in class attributes for introspection<feature59.rst>
   Adding features via inheritance<feature60.rst>   
   Class and per-instance attributes<feature61.rst>
   More on class introspection tools: __class__, __bases__, __dict__<feature62.rst>
   Class interface techniques<feature63.rst>
   Operator overloading: add, sub, and basic indexing<feature64.rst>
   Operator overloading: iteration protocol<feature65.rst>
   Operator overloading: iteration protocol via function generator<feature66.rst>
   Operator overloading: specific membership with __contains__<feature67.rst>
   Operator overloading: __call__, __len__, __bool__<feature68.rst>
   Operator overloading: final MyContainer class<feature69.rst>
   Pseudoprivate class attributes<feature70.rst>
   Unbound and bound methods<feature71.rst>
   Inheritance attribute lister class<feature72.rst>
   Usage of __getattr__ and __getattribute__<feature73.rst>
   Type built-in function applied to classes and instances<feature74.rst>   
   Built-in operations cannot be delegated via __getattr__<feature75.rst>
   Built-in method resolution starts at the class<feature76.rst>
   Method resolution order (MRO)<feature77.rst>
   Tracing instance attributes<feature78.rst>
   Slots<feature79.rst>
   Static methods via built-in function staticmethod()<feature80.rst>
   Static methods via function decorator @staticmethod<feature81.rst>
   Usage of super() in diamond class trees<feature82.rst>
   Constructor calls with multiple inheritance<feature83.rst>   
   Exception handling<feature84.rst>
   Exception hierarchies<feature85.rst>
   Byte and string types<feature86.rst>
   String type conversions<feature87.rst>
   ASCII text<feature88.rst>
   Unicode text<feature89.rst> 
   String and byte literals<feature90.rst>
   Bytes, bytearray and string<feature91.rst>
   The property protocol<feature92.rst>
   Descriptors<feature93.rst>
   Generic attribute management<feature94.rst>
   Proxy pattern<feature95.rst>
   Basic function decorator<feature96.rst>
   Wrapper/proxy pattern with function decorator<feature97.rst>
   Decorator implementation via classes<feature98.rst>
   Decorator for a method of a class<feature99.rst>
   Decorator for a class<feature100.rst>
   Decorator nesting<feature101.rst>
   Decorator arguments<feature102.rst>
   Call tracer with a function decorator<feature103.rst>
   Call tracer with a class descriptor used as decorator<feature104.rst>
   Implementation of the singleton pattern via function attributes<feature105.rst>
   Implementation of the singleton pattern via class decorator<feature106.rst>
   Type<feature107.rst>
   Class statement protocol<feature108.rst>
   Metaclass<feature109.rst>
   Metaclass of a metaclass and __call__ overloading<feature110.rst>
   Adding methods to classes<feature111.rst>
  
Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
